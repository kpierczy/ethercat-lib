/* ============================================================================================================================ *//**
 * @file       config.hpp
 * @author     Krzysztof Pierczyk (krzysztof.pierczyk@gmail.com)
 * @maintainer Krzysztof Pierczyk (krzysztof.pierczyk@gmail.com)
 * @date       Monday, 9th May 2022 5:49:54 pm
 * @modified   Wednesday, 25th June 2025 3:10:12 pm
 * @project    ethercat-lib
 * @brief      Definitions of some compile-time configurations of the library
 *
 *
 * @copyright Krzysztof Pierczyk Â© 2022
 */// ============================================================================================================================= */

#ifndef __ETHERCAT_COMMON_CONFIG_H__
#define __ETHERCAT_COMMON_CONFIG_H__

/* =========================================================== Includes =========================================================== */

// Standard includes
#include <span>
// External includes
#include <boost/beast/core/static_string.hpp>
#include <boost/dynamic_bitset.hpp>
// Private includes
#include "ethercat/common/synchronisation.hpp"

/* ========================================================== Namespaces ========================================================== */

namespace ethercat::config {

/* ====================================================== Types configuration ===================================================== */

namespace types {

    /**
     * @brief Standard synchronisation primitive used by most of synchronsiation-requiring
     *    routines in the library
     */
    using Lock = std::mutex;

    /**
     * @brief Light-weight synchronisation primitive used by the library in short-lock-time,
     *    low-collision-chance locking scenarios
     */
    using QuickLock = common::synchronisation::SpinLock;

    /**
     * @brief Non-owning view of a collection
     */
    template<typename T, auto N = std::dynamic_extent>
    using Span = std::span<T, N>;

    /**
     * @brief Statically-allocated string
     */
    template<std::size_t N>
    using StaticString = boost::beast::static_string<N>;

}

/* ===================================================== General configuration ==================================================== */

/**
 * @brief If @c true library will generate code that will support PDO entries that are not
 *    byte-aligned in the PDI
 *
 * @todo Make Pdo::Entry class respect this config flag. At the moment, the Reference proxy
 *    always takes into account actual bit-offset of data in the PDI (which is usually byte-aligned
 *    due to how TwinCAT generates PDI image; in result data copying is effectively reduced to
 *    - closely - std::copy_n call). Thos should require minimal effort to implement but has been
 *    abandoned at the moment due to project's timing limits.
 */
constexpr bool BitAlignedPdoSupport = true;

/* =================================================== Translation configuration ================================================== */

namespace translation {

    /**
     * @brief If @c true library will require translators to properly handle bit-aligned
     *    objects
     * @details This option does not imply that translator types are required to take
     *    @p bitoffset as an argument. However - if the option is ON - if the translator
     *    does not and the bitoffset of the data buffer is non-zero and exception will be
     *    thrown
     *
     * @note This option is orthogonal with respecte to @ref default_translators::BitAlignedSupport
     *
     * @note At the moment the Slave::Pdo::Entry class has been enchanced with an internal
     *    binary buffer that stores copy of the entry data in the PDI. For this reason, data
     *    is always stored byte-aligned and translator used to convert objects between this
     *    buffer and app-domain entities are not required to support bitoffset themselves.
     *    Such a possibiity in e.g. default constructor is left in case of future changes
     *    but at the moment control of proper bit alignment is controller by the
     *    @ref config::BitAlignedPdoSupport parameter
     */
    constexpr bool RequireBitAlignmentHandling = true;

    /**
     * @brief If @c true library will support translation functions returning boolean flags
     *    that can indicate whether translation succeeded. This can be usefull if exceptions
     *    are not used by the user code.
     */
    constexpr bool SupportBooleanReturn = true;

    /**
     * @brief If @c true library will wrap exception generated by custom translators
     *    into the dedicated exception type
     */
    constexpr bool WrapExceptions = false;

    /**
     * @brief Configuration o default translator types
     */
    namespace default_translators {

        /**
         * @brief If @c true library will generate default translators that support
         *    bit-aligned objects
         *
         * @see translation::RequireBitAlignmentHandling
         */
        constexpr bool BitAlignedSupport = true;

        /**
         * @brief If @c true library will generate default translator that will report
         *    error when it detects invalidity of passed data at runtime, e.g.
         *    when too small byte image buffer is provided to perform translation or
         *    unexpected bit-alignment is detected.
         *
         * @note Such invalid conditions can occur when the ENI file provided by the user is
         *    corrupted and sizes of builtin data types are not correct. If the ENI file
         *    is guaranteed to be properly formatted this flag can eb switched to @p false
         *    to save instructions on conditions verification
         * @note Type of error reporting depends on the value of @ref EnableExceptions and
         *    @ref EnableBooleanReturn flags
         */
        constexpr bool EnableVerification = true;

        /**
         * @brief If @c false library will report error when size of the byte image is bigger
         *    than expected taking into account size characteristic of the translatted type
         *    (for array/vector types it may mean that size of the buffer is no a natural
         *    multiple of expected size of the single element). In general such a condition
         *    may indicate some error in the system (e.g. invalid ENI file). However this
         *    may also be utilized as a feature that allows parsing a single member of the
         *    wider structural type using only a default translator
         *
         * @note This option works in both direction. Enabling it makes default transltor
         *    accept too large data buffer when translating from app-domain type to binary
         *    image
         */
        constexpr bool AllowPartialTranslation = true;

        /**
         * @brief If @c true library will generate default translators that will return boolen
         *    flag indicating whether translation suceeded ( @c false on filure )
         *
         * @note This flag cannot be true if @ref SupportBooleanReturn is disabled
         */
        constexpr bool EnableBooleanReturn = false;

        /**
         * @brief If @c true library will generate exception if verification fails
         * @see EnableVerification
         */
        constexpr bool EnableExceptions = true;

        /**
         * @brief Configuration of the specializations of DefaultTranslator for types derived
         *    from std::string
         */
        namespace string {

            /**
             * @brief As described in the comment of the @ref DefaultTranslator parsing array/vectors
             *    of strings is to some extend arbitrary due to it's dynamic size. For this reason
             *    additional information from the user is required to decide what approach should be
             *    taken by the library
             */
            enum class ArrayMode {

                /**
                 * @brief If set, the library will assume that all strings in the library have size equal
                 *    to the size of the first string. it will not verify this assumption
                 */
                AssumeEqualSize,

                /**
                 * @brief If set, library will examine all string before performing translation. If not
                 *    all string have equal size, a runtime error will be reported.
                 */
                RequireEqualSize,

                /**
                 * @brief If set, library will try to translate all strings according to their actual size.
                 *    This approach is in general incompatible with the EtherCAT protocol but may turn out
                 *    to be usefull in some corner cases.
                 */
                AllowVariableSize

            }; constexpr ArrayMode ArrayParsingMode = ArrayMode::AssumeEqualSize;

        }

        /* ---------------------------- Validate configruation ---------------------------- */

        static_assert(SupportBooleanReturn or (not EnableBooleanReturn),
            "[ethercat::config::default_translators] EnableBooleanReturn cannot be enabled "
            "if boolean return is not supported"
        );

        static_assert(not EnableBooleanReturn or not EnableExceptions,
            "[ethercat::config::default_translators] Reporting and error with both exception "
            "and return value makes not sense (SupportBooleanReturn and EnableExceptions are both enabled)"
        );

        static_assert((not EnableVerification) or (SupportBooleanReturn or EnableExceptions),
            "[ethercat::config::default_translators] EnableVerification is enabled but as neither "
            "EnableBooleanReturn nor EnableExceptions is enabled the defult translator would not be able to "
            "report erronous condition"
        );

    }

}

/* ================================================================================================================================ */

} // End namespace ethercat::config

#endif
